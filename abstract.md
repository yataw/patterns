## Принципы ООП

- абстракция
- инкапсуляция
- полиморфизм
- наследование

## Принципы проектирования
- Инкапсулируйте то, что изменяется
- Предпочитайте композицию наследованию
- Программируйте на уровне интерфейсов
- Стремитесь к слабой связанности взаимодействующих объектов
- Классы должны быть открыты для изменения
- Код должен зависеть от абстракций, а не от конкретных классов (реализаций)
- Принцип минимальной информативности / "Закон" Деметры: класс должен знать только о своих близких друзьях. Из метода объекта должны вызываться методы, принадлежащие:
1. самому объекту
2. параметрам
3. локально объявленному объекту
4. любым компонентам объекта (приватным полям)
- IoС / Голливудский принцип: "Не вызывайте нас - мы сами вас вызовем".
- Класс должен иметь только одну причину для изменений.

## Паттерны

### Стратегия
Изменчивое поведение агрегируем в базовом классе Base переменной IBehaviour behaviour.
За счет агрегации можем динамически переопределять behaviour на любой из субклассов.
### Наблюдатель
Имеем:
1. Subject / Observable (наблюдаемый объект)
2. Observers / Subscribers (наблюдатели / подписчики)

Subject:
- registerObserver()
- removeObserver()
- notifyObservers()

Observer:
-update() // вызывается при событии notifyObservers()

Два варианта: с активной доставкой update(payload) и без update()

### Декоратор
Дан внешний абстрактный класс Base и его реализации A, B, C.

Декоратор использует поведение реализации, и как-то модифицирует его.
Для этого BaseDecorator наследуется от Base и агрегирует Base (допустим, Base base).
Конкретая реализация ConcreteDecorator переопределяет метод foo из Base как-то так:
ConcreteDecorator.foo = function() {
return this.smth() + base.foo();
};

### Фабрика
#### Простая фабрика
Есть интерфейс Pizza и несколько реализаций. Параметризуем реализацию:
function order(type) {
Pizza pizza;

if (type === "cheese")
pizza = new CheesePizza()
else if (type === 'pepperoni')
pizza = new PepperoniPizza()
...

pizza.prepare();
pizza.cut();
pizza.box();

return pizza;
}

#### Фабричный метод
Уже два параметра: тип пиццы (маргарита, пепперони) и стиль пиццы (по-нью-йоркски, по-техасски)

Применяем паттерн шаблонный метод для создания экземпляра класса (абстрактный класс с абстрактным методом create(type)). Суперкласс может содержать и другие методы (например, order)
Тип пиццы остается в методе create, потомки субклассируют стиль.

#### Абстрактная фабрика
Абстрактный класс с одним методом create(type)
Конкретные потомки ConcreteFactory определяют стиль.

### Одиночка (Singleton)
содержит:
- static uniqueInstance
- static getUniqueInstance();

Используй volitile static uniqInstance в многопоточной среде.

### Команда
ICommand:
- execute()
- undo()

ConcreteCommand implements ICommand:
- ConcreteCommand(Executor executor) {this.executor = executor;}  # Инкапсулирует в себе реального исполнителя
- execute() {this.executor.makeSmth();}
- undo() {...}

### Адаптер
Надо свести ITheirs к IOurs.

#### Адаптер объектов (классический адаптер)
Наследуемся от IOurs, делегируем все ConcreteTheirs.

#### Адаптер классов
Множественное наследование от ITheirs и IOurs

### Фасад
Предоставляет ограниченный, но легкий и удобный интерфейс к большому api (какой-то группе интерфейсов).

### Шаблонный метод
Задаем алгоритм (последовательность вызовов методов) в базовом классе.
Некоторые его шаги реализуем потомками.

Перехватчик - метод с пустой реализацией в базовом классе.

### Итератор
Предоставляет механизм последовательного перебора коллекции.

- hasNext()
- next() #/ returns element
- remove()

Внешний итератор - когда итератор вытащен наружу. Мы можем вызывать методы hasNext() и next()
Внутренний - когда мы передаем функцию, которая должна выполнится с элементами коллекции (напр, компаратор). Как именно они перебираются скрыто реализацией.

### Компоновщик
Для выполнения операций на древовидных структурах из однотипных элементов.

- Leaf implements Node # хранит null в качестве коллекции (напр. массив) потомков
- Composite implements Node # хранит непустую коллекцию потомков

### Состояние
Позволяет реализовать конечный автомат.

Mashine:
- State state
- setState(state)
- method(param) {this.state.method(param)} # мутирующие методы делегируют управление объекту состояния

State:
- Machine machine
- method(param) {
this.doSmth();
this.machine.setState(anotherState); # Объект состояния переводит machine в новое состояние
}

Отличия от стратегии:
- Стратегия сама не знает ничего о других стратегиях и не меняет текущую стратегию класса-хозяина.
- В стратегиях нет никаких четкого набора переходов к другим стратегиям

### Заместитель (Proxy)
Proxy наследуется от Subject и агрегирует его.

- Удаленный заместитель # Локальный представитель для объекта из другого адресного пространства
- Виртуальный заместитель # Управляет доступом к объекту, треюущего больших затрат при инициализации. Пример: пока с сервера грузится обложка альбома, заместитель показывает прелоадер. Заместитель заменит прелоадер на картинку как только та загрузится.
- Защитный заместитель # Управляет правами доступа в разрезе разных пользователей. Пример: один пользователь хочет взаимодействовать с другим. Тогда ему выдается заместитель другого пользователя.

### MVC
1. **Model** (Модель)
Хранит все данные, информацию состояния и логику приложения. Не знает о существовании представления и контроллера, хотя предоставляет интерфейс для получения/изменения состояния. Отправляет оповещения об изменениях наблюдателям.
2. **View** (Представление)
Определяет представление модели. Как правило, представление получает состояние и данные для отображения непосредственно от модели.
3. **Controller** (Контроллер)
Получает данные, вводимые пользователем, и определяет их смысл для модели

Сценарий работы:
1. **Пользователь взаимодействует с моделью**
Представление - "окно", через которое пользователь воспринимает модель. Когда вы делаете что-то с представлением (скажем, щелкаете на кнопке воспроизведения), представление сообщает контроллеру, какая операция была выполнена. Контроллер должен обработать это действие.
2. **Контроллер обращается к модели с запросами об изменении состояния**
Контроллер получает действия пользователя и интерпретирует их. Если вы щелкаете на кнопке, контроллер должен разобраться, что это значит и какие операции с моделью должны быть выполнены при данном действии.
3. **Контроллер также может обратиться к представлению с запросом об изменении**
Когда контроллер получает действие от представления, в результате его обработки он может обратиться к представлению с запросом на изменение (скажем, заблокировать некоторые кнопки или команды меню).
4. **Модель оповещает представление об изменении состояния**
Когда в модели что-то изменяется (вследствие действий пользователя или других внутренних изменений — скажем, перехода к следующей песне в списке), модель оповещает представление об изменении состояния.
5. **Представление запрашивает у модели информацию состояния**
Представление получает отображаемую информацию состояния непосредственно от модели. Например, когда модель оповещает представление о начале воспроизведения новой песни, представление запрашивает название песни и отображает его. Представление также может запросить у модели информацию состояния в результате запроса на изменение состояние со стороны контроллера.

## Материалы

- Композиция, агрегация, делегация, ассоциация: https://ru.stackoverflow.com/a/229096/233185